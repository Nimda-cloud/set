#!/usr/bin/env python3
"""
Malware Detection and Analysis Module for NIMDA Security System
Provides comprehensive trojan detection, file isolation, and ecosystem analysis
"""

import os
import time
import json
import psutil
import subprocess
from datetime import datetime
from typing import Dict, List, Tuple, Optional

class MalwareDetector:
    """Advanced malware detection and analysis system"""
    
    def __init__(self):
        self.quarantine_dir = "/tmp/nimda_quarantine"
        self.analysis_dir = "/tmp/nimda_analysis"
        self.suspicious_patterns = [
            'trojan', 'virus', 'malware', 'backdoor', 'keylogger',
            'spyware', 'rootkit', 'botnet', 'crypto', 'miner'
        ]
        self.suspicious_extensions = ['.exe', '.bat', '.cmd', '.scr', '.pif', '.com']
        self.unusual_ports = [4444, 5555, 31337, 1337, 6667, 6668, 6669]
        
        # Create directories
        os.makedirs(self.quarantine_dir, exist_ok=True)
        os.makedirs(self.analysis_dir, exist_ok=True)
    
    def detect_trojan(self, target: str, details: Dict) -> Dict:
        """Detect trojan and malicious software"""
        print(f"🦠 Detecting trojan/malware: {target}")
        
        detection_result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'suspicious_processes': [],
            'suspicious_files': [],
            'suspicious_connections': [],
            'trojan_indicators': [],
            'risk_level': 'LOW',
            'recommendations': []
        }
        
        try:
            # Get suspicious processes
            suspicious_processes = self._find_suspicious_processes()
            detection_result['suspicious_processes'] = suspicious_processes
            
            # Get suspicious files
            suspicious_files = self._find_suspicious_files()
            detection_result['suspicious_files'] = suspicious_files
            
            # Get network connections for analysis
            suspicious_connections = self._find_suspicious_connections()
            detection_result['suspicious_connections'] = suspicious_connections
            
            # Analyze for trojan patterns
            trojan_indicators = self._analyze_trojan_indicators(
                suspicious_processes, suspicious_files, suspicious_connections
            )
            detection_result['trojan_indicators'] = trojan_indicators
            
            # Assess risk level
            detection_result['risk_level'] = self._assess_detection_risk(detection_result)
            
            # Generate recommendations
            detection_result['recommendations'] = self._generate_recommendations(detection_result)
            
            if trojan_indicators:
                print(f"🚨 Trojan detected! Indicators: {len(trojan_indicators)}")
                print(f"📊 Risk Level: {detection_result['risk_level']}")
            else:
                print(f"✅ No trojan detected for: {target}")
                
        except Exception as e:
            print(f"❌ Trojan detection failed: {e}")
            detection_result['error'] = str(e)
        
        return detection_result
    
    def isolate_file(self, target: str, details: Dict) -> Dict:
        """Isolate suspicious file"""
        print(f"🔒 Isolating file: {target}")
        
        isolation_result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'quarantine_path': None,
            'success': False,
            'error': None
        }
        
        try:
            if os.path.exists(target):
                filename = os.path.basename(target)
                quarantine_path = os.path.join(
                    self.quarantine_dir, 
                    f"quarantined_{int(time.time())}_{filename}"
                )
                
                # Copy file to quarantine
                success, output = self._execute_with_privileges(f"cp '{target}' '{quarantine_path}'")
                
                if success:
                    # Set restrictive permissions
                    self._execute_with_privileges(f"chmod 000 '{quarantine_path}'")
                    
                    # Log isolation
                    isolation_log = {
                        'original_path': target,
                        'quarantine_path': quarantine_path,
                        'timestamp': datetime.now().isoformat(),
                        'reason': 'Suspicious file detected'
                    }
                    
                    # Save isolation log
                    log_file = os.path.join(self.quarantine_dir, "isolation_log.json")
                    with open(log_file, 'a') as f:
                        f.write(json.dumps(isolation_log) + '\n')
                    
                    isolation_result['quarantine_path'] = quarantine_path
                    isolation_result['success'] = True
                    print(f"✅ File isolated: {target} -> {quarantine_path}")
                else:
                    isolation_result['error'] = output
                    print(f"❌ Failed to isolate file: {output}")
            else:
                isolation_result['error'] = "File not found"
                print(f"⚠️ File not found: {target}")
                
        except Exception as e:
            isolation_result['error'] = str(e)
            print(f"❌ File isolation failed: {e}")
        
        return isolation_result
    
    def deep_analysis(self, target: str, details: Dict) -> Dict:
        """Perform deep analysis of target"""
        print(f"🔬 Deep analysis: {target}")
        
        analysis_result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'file_analysis': {},
            'process_analysis': {},
            'network_analysis': {},
            'config_analysis': {},
            'success': False,
            'error': None
        }
        
        try:
            # Analyze file structure
            analysis_result['file_analysis'] = self._analyze_file_structure(target)
            
            # Analyze process behavior
            analysis_result['process_analysis'] = self._analyze_process_behavior(target)
            
            # Analyze network patterns
            analysis_result['network_analysis'] = self._analyze_network_patterns(target)
            
            # Analyze configuration changes
            analysis_result['config_analysis'] = self._analyze_configuration_changes(target)
            
            # Save analysis report
            analysis_file = os.path.join(
                self.analysis_dir, 
                f"deep_analysis_{int(time.time())}.json"
            )
            with open(analysis_file, 'w') as f:
                json.dump(analysis_result, f, indent=2)
            
            analysis_result['success'] = True
            print(f"✅ Deep analysis completed: {analysis_file}")
            
        except Exception as e:
            analysis_result['error'] = str(e)
            print(f"❌ Deep analysis failed: {e}")
        
        return analysis_result
    
    def quarantine_target(self, target: str, details: Dict) -> Dict:
        """Quarantine target completely"""
        print(f"🚫 Quarantining: {target}")
        
        quarantine_result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'terminated_processes': [],
            'isolated_files': [],
            'blocked_connections': [],
            'success': False,
            'error': None
        }
        
        try:
            # Stop all related processes
            related_processes = self._find_related_processes(target)
            for proc in related_processes:
                success, output = self._execute_with_privileges(f"kill -9 {proc['pid']}")
                if success:
                    quarantine_result['terminated_processes'].append(proc)
                    print(f"💀 Terminated process: {proc['name']} (PID: {proc['pid']})")
            
            # Isolate files
            related_files = self._find_related_files(target)
            for file_path in related_files:
                isolation_result = self.isolate_file(file_path, details)
                if isolation_result['success']:
                    quarantine_result['isolated_files'].append(file_path)
            
            # Block network connections
            related_connections = self._find_related_connections(target)
            for conn in related_connections:
                if conn.get('remote_addr'):
                    # Block IP using pfctl
                    ip = conn['remote_addr'].split(':')[0]
                    success, output = self._execute_with_privileges(
                        f"echo 'block drop in from {ip} to any' | pfctl -ef -"
                    )
                    if success:
                        quarantine_result['blocked_connections'].append(conn)
            
            quarantine_result['success'] = True
            print(f"✅ Quarantine completed for: {target}")
            
        except Exception as e:
            quarantine_result['error'] = str(e)
            print(f"❌ Quarantine failed: {e}")
        
        return quarantine_result
    
    def remove_malware(self, target: str, details: Dict) -> Dict:
        """Remove malware completely"""
        print(f"🧹 Removing malware: {target}")
        
        removal_result = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'removed_files': [],
            'killed_processes': [],
            'cleaned_configs': [],
            'restored_backups': [],
            'success': False,
            'error': None
        }
        
        try:
            # First, perform deep analysis
            analysis_result = self.deep_analysis(target, details)
            
            # Find all related components
            ecosystem = self.analyze_ecosystem(target, details)
            
            # Remove files
            for file_info in ecosystem.get('files', []):
                file_path = file_info.get('path')
                if file_path and os.path.exists(file_path):
                    success, output = self._execute_with_privileges(f"rm -f '{file_path}'")
                    if success:
                        removal_result['removed_files'].append(file_path)
                        print(f"🗑️ Removed file: {file_path}")
                    else:
                        print(f"❌ Failed to remove file: {file_path}")
            
            # Kill processes
            for proc_info in ecosystem.get('processes', []):
                pid = proc_info.get('pid')
                if pid:
                    success, output = self._execute_with_privileges(f"kill -9 {pid}")
                    if success:
                        removal_result['killed_processes'].append(proc_info)
                        print(f"💀 Killed process: {proc_info.get('name')} (PID: {pid})")
                    else:
                        print(f"❌ Failed to kill process: {pid}")
            
            # Clean configuration changes
            config_changes = ecosystem.get('config_changes', [])
            for change in config_changes:
                cleaned = self._clean_configuration_change(change)
                if cleaned:
                    removal_result['cleaned_configs'].append(change)
            
            # Restore from backup if available
            if ecosystem.get('backup_available'):
                restored = self._restore_from_backup(target, details)
                if restored:
                    removal_result['restored_backups'].append(target)
            
            removal_result['success'] = True
            print(f"✅ Malware removal completed for: {target}")
            
        except Exception as e:
            removal_result['error'] = str(e)
            print(f"❌ Malware removal failed: {e}")
        
        return removal_result
    
    def analyze_ecosystem(self, target: str, details: Dict) -> Dict:
        """Analyze entire malware ecosystem"""
        print(f"🌐 Analyzing ecosystem: {target}")
        
        ecosystem = {
            'target': target,
            'timestamp': datetime.now().isoformat(),
            'files': [],
            'processes': [],
            'connections': [],
            'config_changes': [],
            'backup_available': False,
            'risk_level': 'UNKNOWN',
            'success': False,
            'error': None
        }
        
        try:
            # Find related files
            ecosystem['files'] = self._find_related_files(target)
            
            # Find related processes
            ecosystem['processes'] = self._find_related_processes(target)
            
            # Find related network connections
            ecosystem['connections'] = self._find_related_connections(target)
            
            # Find configuration changes
            ecosystem['config_changes'] = self._find_configuration_changes(target)
            
            # Check for backups
            ecosystem['backup_available'] = self._check_backup_availability(target)
            
            # Assess overall risk
            ecosystem['risk_level'] = self._assess_ecosystem_risk(ecosystem)
            
            # Save ecosystem analysis
            ecosystem_file = os.path.join(
                self.analysis_dir, 
                f"ecosystem_{int(time.time())}.json"
            )
            with open(ecosystem_file, 'w') as f:
                json.dump(ecosystem, f, indent=2)
            
            ecosystem['success'] = True
            print(f"✅ Ecosystem analysis completed: {ecosystem_file}")
            print(f"📊 Risk Level: {ecosystem['risk_level']}")
            print(f"📁 Files: {len(ecosystem['files'])}")
            print(f"⚙️ Processes: {len(ecosystem['processes'])}")
            print(f"🌐 Connections: {len(ecosystem['connections'])}")
            
        except Exception as e:
            ecosystem['error'] = str(e)
            print(f"❌ Ecosystem analysis failed: {e}")
        
        return ecosystem
    
    # Helper methods
    def _find_suspicious_processes(self) -> List[Dict]:
        """Find suspicious processes"""
        suspicious = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'cpu_percent', 'memory_percent']):
                try:
                    proc_info = proc.info
                    if self._is_suspicious_process(proc_info):
                        suspicious.append(proc_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
        except Exception as e:
            print(f"Error finding suspicious processes: {e}")
        return suspicious
    
    def _find_suspicious_files(self) -> List[str]:
        """Find suspicious files"""
        suspicious = []
        try:
            # Check common malware locations
            suspicious_paths = [
                '/tmp', '/var/tmp', '/Users/*/Downloads',
                '/Users/*/Desktop', '/Users/*/Documents'
            ]
            
            for path_pattern in suspicious_paths:
                try:
                    for root, dirs, files in os.walk(path_pattern):
                        for file in files:
                            file_path = os.path.join(root, file)
                            if self._is_suspicious_file(file_path):
                                suspicious.append(file_path)
                except (PermissionError, FileNotFoundError):
                    continue
        except Exception as e:
            print(f"Error finding suspicious files: {e}")
        return suspicious
    
    def _find_suspicious_connections(self) -> List[Dict]:
        """Find suspicious network connections"""
        suspicious = []
        try:
            connections = psutil.net_connections()
            for conn in connections:
                if self._is_suspicious_connection(conn):
                    suspicious.append({
                        'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else None,
                        'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                        'status': conn.status,
                        'pid': conn.pid
                    })
        except Exception as e:
            print(f"Error finding suspicious connections: {e}")
        return suspicious
    
    def _analyze_trojan_indicators(self, processes: List, files: List, connections: List) -> List[str]:
        """Analyze for trojan indicators"""
        indicators = []
        
        # Check for high CPU/memory usage
        for proc in processes:
            if proc.get('cpu_percent', 0) > 80 or proc.get('memory_percent', 0) > 50:
                indicators.append(f"High resource usage: {proc.get('name')}")
        
        # Check for suspicious file names
        for file_path in files:
            filename = os.path.basename(file_path).lower()
            if any(pattern in filename for pattern in self.suspicious_patterns):
                indicators.append(f"Suspicious filename: {filename}")
        
        # Check for external connections
        for conn in connections:
            if conn.get('remote_addr'):
                remote_ip = conn['remote_addr'].split(':')[0]
                if not self._is_internal_ip(remote_ip):
                    indicators.append(f"External connection: {remote_ip}")
        
        return indicators
    
    def _is_suspicious_process(self, proc_info: Dict) -> bool:
        """Check if process is suspicious"""
        name = proc_info.get('name', '').lower()
        cmdline = ' '.join(proc_info.get('cmdline', [])).lower()
        return any(pattern in name or pattern in cmdline for pattern in self.suspicious_patterns)
    
    def _is_suspicious_file(self, file_path: str) -> bool:
        """Check if file is suspicious"""
        filename = os.path.basename(file_path).lower()
        extension = os.path.splitext(filename)[1].lower()
        
        # Check extension
        if extension in self.suspicious_extensions:
            return True
        
        # Check filename patterns
        return any(pattern in filename for pattern in self.suspicious_patterns)
    
    def _is_suspicious_connection(self, conn) -> bool:
        """Check if connection is suspicious"""
        if not conn.raddr:
            return False
        
        remote_ip = conn.raddr.ip
        
        # Check for known malicious IPs (example)
        malicious_ips = [
            '192.168.1.100',  # Example
            '10.0.0.100'      # Example
        ]
        
        if remote_ip in malicious_ips:
            return True
        
        # Check for unusual ports
        if conn.raddr.port in self.unusual_ports:
            return True
        
        return False
    
    def _is_internal_ip(self, ip: str) -> bool:
        """Check if IP is internal"""
        internal_ranges = [
            '127.', '192.168.', '10.', '172.16.', '172.17.', '172.18.',
            '172.19.', '172.20.', '172.21.', '172.22.', '172.23.', '172.24.',
            '172.25.', '172.26.', '172.27.', '172.28.', '172.29.', '172.30.', '172.31.'
        ]
        return any(ip.startswith(range_prefix) for range_prefix in internal_ranges)
    
    def _find_related_processes(self, target: str) -> List[Dict]:
        """Find processes related to target"""
        related = []
        try:
            for proc in psutil.process_iter(['pid', 'name', 'cmdline', 'exe']):
                try:
                    proc_info = proc.info
                    if self._is_process_related_to_target(proc_info, target):
                        related.append(proc_info)
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    continue
        except Exception as e:
            print(f"Error finding related processes: {e}")
        return related
    
    def _find_related_files(self, target: str) -> List[Dict]:
        """Find files related to target"""
        related = []
        try:
            if os.path.exists(target):
                related.append({'path': target, 'type': 'target'})
                
                # Find files in same directory
                dir_path = os.path.dirname(target)
                if os.path.exists(dir_path):
                    for file in os.listdir(dir_path):
                        file_path = os.path.join(dir_path, file)
                        if os.path.isfile(file_path) and file_path != target:
                            related.append({'path': file_path, 'type': 'related'})
        except Exception as e:
            print(f"Error finding related files: {e}")
        return related
    
    def _find_related_connections(self, target: str) -> List[Dict]:
        """Find network connections related to target"""
        related = []
        try:
            connections = psutil.net_connections()
            for conn in connections:
                if self._is_connection_related_to_target(conn, target):
                    related.append({
                        'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else None,
                        'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                        'status': conn.status,
                        'pid': conn.pid
                    })
        except Exception as e:
            print(f"Error finding related connections: {e}")
        return related
    
    def _find_configuration_changes(self, target: str) -> List[Dict]:
        """Find configuration changes related to target"""
        changes = []
        try:
            # Check for recent changes in common config locations
            config_paths = [
                '/etc/hosts', '/etc/passwd', '/etc/shadow',
                '/Users/*/Library/Preferences',
                '/Users/*/Library/LaunchAgents',
                '/Users/*/Library/LaunchDaemons'
            ]
            
            for path_pattern in config_paths:
                try:
                    if os.path.exists(path_pattern):
                        stat = os.stat(path_pattern)
                        # Check if modified recently (last 24 hours)
                        if time.time() - stat.st_mtime < 86400:
                            changes.append({
                                'path': path_pattern,
                                'modified': datetime.fromtimestamp(stat.st_mtime).isoformat()
                            })
                except (PermissionError, FileNotFoundError):
                    continue
        except Exception as e:
            print(f"Error finding configuration changes: {e}")
        return changes
    
    def _check_backup_availability(self, target: str) -> bool:
        """Check if backup is available for target"""
        try:
            # Check for Time Machine backups on macOS
            backup_paths = [
                '/Volumes/*/Backups.backupdb',
                '/Users/*/Library/Application Support/Time Machine'
            ]
            
            for path_pattern in backup_paths:
                if os.path.exists(path_pattern):
                    return True
        except Exception as e:
            print(f"Error checking backup availability: {e}")
        return False
    
    def _assess_ecosystem_risk(self, ecosystem: Dict) -> str:
        """Assess overall risk of ecosystem"""
        risk_score = 0
        
        # Count suspicious components
        risk_score += len(ecosystem.get('files', [])) * 10
        risk_score += len(ecosystem.get('processes', [])) * 20
        risk_score += len(ecosystem.get('connections', [])) * 15
        risk_score += len(ecosystem.get('config_changes', [])) * 25
        
        # Determine risk level
        if risk_score >= 100:
            return 'CRITICAL'
        elif risk_score >= 50:
            return 'HIGH'
        elif risk_score >= 20:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _assess_detection_risk(self, detection_result: Dict) -> str:
        """Assess risk level from detection results"""
        risk_score = 0
        
        risk_score += len(detection_result.get('suspicious_processes', [])) * 20
        risk_score += len(detection_result.get('suspicious_files', [])) * 10
        risk_score += len(detection_result.get('suspicious_connections', [])) * 15
        risk_score += len(detection_result.get('trojan_indicators', [])) * 25
        
        if risk_score >= 100:
            return 'CRITICAL'
        elif risk_score >= 50:
            return 'HIGH'
        elif risk_score >= 20:
            return 'MEDIUM'
        else:
            return 'LOW'
    
    def _generate_recommendations(self, detection_result: Dict) -> List[str]:
        """Generate recommendations based on detection results"""
        recommendations = []
        
        if detection_result.get('suspicious_processes'):
            recommendations.append("Terminate suspicious processes immediately")
        
        if detection_result.get('suspicious_files'):
            recommendations.append("Isolate suspicious files for analysis")
        
        if detection_result.get('suspicious_connections'):
            recommendations.append("Block suspicious network connections")
        
        if detection_result.get('trojan_indicators'):
            recommendations.append("Perform deep analysis of affected components")
            recommendations.append("Consider full system quarantine")
        
        if detection_result.get('risk_level') in ['HIGH', 'CRITICAL']:
            recommendations.append("Initiate emergency response procedures")
            recommendations.append("Notify security team immediately")
        
        return recommendations
    
    def _is_process_related_to_target(self, proc_info: Dict, target: str) -> bool:
        """Check if process is related to target"""
        try:
            cmdline = ' '.join(proc_info.get('cmdline', [])).lower()
            exe = proc_info.get('exe', '').lower()
            target_lower = target.lower()
            return target_lower in cmdline or target_lower in exe
        except:
            return False
    
    def _is_connection_related_to_target(self, conn, target: str) -> bool:
        """Check if connection is related to target"""
        try:
            if conn.pid:
                proc = psutil.Process(conn.pid)
                cmdline = ' '.join(proc.cmdline()).lower()
                target_lower = target.lower()
                return target_lower in cmdline
        except:
            pass
        return False
    
    def _analyze_file_structure(self, target: str) -> Dict:
        """Analyze file structure"""
        analysis = {}
        try:
            if os.path.exists(target):
                stat = os.stat(target)
                analysis = {
                    'size': stat.st_size,
                    'permissions': oct(stat.st_mode),
                    'modified': datetime.fromtimestamp(stat.st_mtime).isoformat(),
                    'created': datetime.fromtimestamp(stat.st_ctime).isoformat(),
                    'is_executable': os.access(target, os.X_OK)
                }
        except Exception as e:
            analysis['error'] = str(e)
        return analysis
    
    def _analyze_process_behavior(self, target: str) -> Dict:
        """Analyze process behavior"""
        analysis = {}
        try:
            related_processes = self._find_related_processes(target)
            
            for proc_info in related_processes:
                pid = proc_info.get('pid')
                if pid:
                    try:
                        proc = psutil.Process(pid)
                        analysis[pid] = {
                            'name': proc.name(),
                            'cpu_percent': proc.cpu_percent(),
                            'memory_percent': proc.memory_percent(),
                            'num_threads': proc.num_threads(),
                            'connections': len(proc.connections()),
                            'open_files': len(proc.open_files())
                        }
                    except (psutil.NoSuchProcess, psutil.AccessDenied):
                        continue
        except Exception as e:
            analysis['error'] = str(e)
        return analysis
    
    def _analyze_network_patterns(self, target: str) -> Dict:
        """Analyze network patterns"""
        analysis = {}
        try:
            connections = psutil.net_connections()
            target_connections = []
            
            for conn in connections:
                if self._is_connection_related_to_target(conn, target):
                    target_connections.append({
                        'local_addr': f"{conn.laddr.ip}:{conn.laddr.port}" if conn.laddr else None,
                        'remote_addr': f"{conn.raddr.ip}:{conn.raddr.port}" if conn.raddr else None,
                        'status': conn.status,
                        'family': conn.family,
                        'type': conn.type
                    })
            
            analysis['connections'] = target_connections
            analysis['total_connections'] = len(target_connections)
            
        except Exception as e:
            analysis['error'] = str(e)
        return analysis
    
    def _analyze_configuration_changes(self, target: str) -> List[Dict]:
        """Analyze configuration changes"""
        return self._find_configuration_changes(target)
    
    def _clean_configuration_change(self, change: Dict) -> bool:
        """Clean configuration change"""
        try:
            path = change.get('path')
            if path and os.path.exists(path):
                print(f"🧹 Cleaning configuration: {path}")
                return True
        except Exception as e:
            print(f"Error cleaning configuration: {e}")
        return False
    
    def _restore_from_backup(self, target: str, details: Dict) -> bool:
        """Restore from backup"""
        try:
            print(f"🔄 Restoring from backup: {target}")
            # Implementation would depend on backup system
            return True
        except Exception as e:
            print(f"Error restoring from backup: {e}")
            return False
    
    def _execute_with_privileges(self, command: str) -> Tuple[bool, str]:
        """Execute command with privileges"""
        try:
            result = subprocess.run(['sudo', '-n'] + command.split(), 
                                  capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                return True, result.stdout
            else:
                return False, result.stderr
        except subprocess.TimeoutExpired:
            return False, "Command timed out"
        except Exception as e:
            return False, str(e) 